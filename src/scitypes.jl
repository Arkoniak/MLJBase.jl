nlevels(c::CategoricalValue) = length(levels(c.pool))
nlevels(c::CategoricalString) = length(levels(c.pool))

"""
    scitype(x)

The scientific type that `x` may represent.

    julia> scitype(4.5)
    Continous

    julia> scitype("book")
    Unknown

    julia> using CategoricalArrays
    julia> v = categorical([:m, :f, :f])
    julia> scitype(v[1])
    Multiclass{2}

    julia> scitype(v)
    VectorScitype(Multiclass{2})

    julia> X = (x1=rand(3), x2=rand(Int, 3), x3=rand(3))
    julia> scitype(X)
    TableScitype(Set(DataType[Count, Continuous]))
 
    julia> scitype((42, float(π), "Julia"))
    Tuple{Count,Continuous,Unknown}

For getting the union of the scitypes of all elements of an iterable,
use `scitype_union`. For inspecting in detail the internal scitypes of
a container, use `scitypes`. Compare scitypes with `⊂`.

"""
function scitype end


"""
    scitype_union(A)

Return the type union, over all elements `x` generated by the iterable
`A`, of `scitype(x)`. Fails if an element of A has a scitype that is
not also a julia type.

"""
scitype_union(A) = reduce((a,b)->Union{a,b}, (scitype(el) for el in A))


## BASIC STRUCTURE OF SCITYPES

# 0. Scitypes, dilineated by the `is_scitype` trait, are objects that
# are sometimes julia types and sometimes not.

# 1. By default, no object is a scitype:
is_scitype(::Any) = false

# 2. A collection of julia types called *atomic scitypes* - by
# definition, the subtypes of `AtomicScitypes` below - are all
# scitypes.

# 3. The closure C in the set of all julia types, under the
# operation Tuple{...} and Union{...}, is a collection of scitypes:
is_scitype(T::Type{<:Tuple}) = reduce(&, [is_scitype(p) for p in T.parameters])
is_scitype(U::Union) = is_scitype(U.a) && is_scitype(U.b)

# 4. C is *all* of the scitypes that are simultaneously
# julia types. That is, a julia type that cannot be constructed from
# atomic scitypes using the basic union and tuple operations is
# forbidden to be a scitype.

# 5. The the scitype partial order restricts to the julia type partial
# order on C:
⊂(a, b) = false # to be overidden for non-julia scitypes
⊂(a::DataType, b::DataType) = a <: b

# fallbacks for the scitype method (taking scitypes as values):
scitype(t::Tuple) = Tuple{scitype.(t)...}
scitype(X) = scitype(X, Val(container_type(X)))
scitype(::Any, ::Val{:other}) = Unknown     


## ATOMIC SCITYPES

abstract type Found end
struct Unknown <: Found end 
abstract type Known <: Found end
abstract type Image <: Known end
struct GrayImage <: Image end
struct ColorImage <: Image end
abstract type Infinite <: Known end
struct Continuous <: Infinite end
struct Count <: Infinite end
abstract type Finite{N} <: Known end
struct Multiclass{N} <: Finite{N} end
struct OrderedFactor{N} <: Finite{N} end

# aliases:
const Binary = Multiclass{2}
const AtomicScitype = Union{Missing,Found}

is_scitype(::Type{<:AtomicScitype}) = true

scitype(::Missing) = Missing
scitype(::AbstractFloat) = Continuous
scitype(::Integer) = Count
scitype(c::CategoricalValue) =
    c.pool.ordered ? OrderedFactor{nlevels(c)} : Multiclass{nlevels(c)}
scitype(c::CategoricalString) = 
    c.pool.ordered ? OrderedFactor{nlevels(c)} : Multiclass{nlevels(c)}
scitype(::AbstractArray{<:ColorTypes.Gray,2}) = GrayImage
scitype(::AbstractArray{<:ColorTypes.AbstractRGB,2}) = ColorImage


## VECTORS

struct VectorScitype <: MLJType
    eltype
    function VectorScitype(eltype)
        is_scitype(eltype) || throw(ArgumentError)
        return new(eltype)
    end
end

is_scitype(v::VectorScitype) = true

⊂(v1::VectorScitype, v2::VectorScitype) = ⊂(v1.eltype, v2.eltype)

scitype(v::AbstractVector) = VectorScitype(scitype_union(v))


## SCITYPES WITHIN A CONTAINER (SCITYPE SCHEMA)

scitypes(X) = scitypes(X, Val(container_type(X)))
scitypes(X, ::Val{:other}) = throw(ArgumentError("Unknown container type. "))


## TABLES

"""
    scitypes(X)

Inspect the internal scitypes of a container object - the column
scitypes of a table, for example.

"""
function scitypes(X, ::Val{:table})
    container_type(X) in [:table, :sparse] ||
        throw(ArgumentError("Container should be a table or sparse table. "))
    names =    schema(X).names
    return NamedTuple{names}(scitype_union(selectcols(X, c)) for c in names)
end

# we use instances of the following as scitypes for tables:
struct TableScitype <: MLJType
    column_types::Set
    function TableScitype(column_types)
        okay = reduce(&, [is_scitype(T) for T in column_types])
        okay || throw(ArgumentError)
        return new(column_types)
    end
end

is_scitype(v::TableScitype) = true

function is_subtype_of_one(T, S::Set{<:Type})
    isempty(S) && return false
    return reduce(|, [T <: T2 for T2 in S])
end
⊂(t1::TableScitype, t2::TableScitype) =
    reduce(&, [is_subtype_of_one(T, t2.column_types)
               for T in t1.column_types])

scitype(X, ::Val{:table}) = TableScitype(Set(values(scitypes(X))))



    






