nlevels(c::CategoricalValue) = length(levels(c.pool))
nlevels(c::CategoricalString) = length(levels(c.pool))

"""
    scitype(x)

The scientific type that `x` may represent.

    julia> scitype(4.5)
    Continous

    julia> scitype("book")
    Unknown

    julia> using CategoricalArrays
    julia> v = categorical([:m, :f, :f])
    julia> scitype(v[1])
    Multiclass{2}

    julia> scitype(v)
    AbstractArray{Multiclass{2}, 1}

    julia> X = (x1=rand(3), x2=rand(Int, 3), x3=rand(3))
    julia> scitype(X)
    Table{Union{Col{Continuous}, Col{Count}}}
 
    julia> scitype((42, float(Ï€), "Julia"))
    Tuple{Count,Continuous,Unknown}

For getting the union of the scitypes of all elements of an iterable,
use `scitype_union`. For inspecting in detail the internal scitypes of
a container, use `scitypes`. 

"""
function scitype end


"""
    scitype_union(A)

Return the type union, over all elements `x` generated by the iterable
`A`, of `scitype(x)`. Fails if an element of A has a scitype that is
not also a julia type.

"""
scitype_union(A) = reduce((a,b)->Union{a,b}, (scitype(el) for el in A))

# fallbacks for the scitype method (taking scitypes as values):
scitype(X) = scitype(X, Val(container_type(X)))
scitype(::Any, ::Val{:other}) = Unknown     


## ATOMIC SCITYPES

abstract type Found end
struct Unknown <: Found end 
abstract type Known <: Found end
abstract type Image <: Known end
struct GrayImage <: Image end
struct ColorImage <: Image end
abstract type Infinite <: Known end
struct Continuous <: Infinite end
struct Count <: Infinite end
abstract type Finite{N} <: Known end
struct Multiclass{N} <: Finite{N} end
struct OrderedFactor{N} <: Finite{N} end

# aliases:
const Binary = Multiclass{2}
const AtomicScitype = Union{Missing,Found}

scitype(::Missing) = Missing
scitype(::AbstractFloat) = Continuous
scitype(::Integer) = Count
scitype(c::CategoricalValue) =
    c.pool.ordered ? OrderedFactor{nlevels(c)} : Multiclass{nlevels(c)}
scitype(c::CategoricalString) = 
    c.pool.ordered ? OrderedFactor{nlevels(c)} : Multiclass{nlevels(c)}
scitype(::AbstractArray{<:ColorTypes.Gray,2}) = GrayImage
scitype(::AbstractArray{<:ColorTypes.AbstractRGB,2}) = ColorImage


## SCITYPES OF TUPLES ARE TUPLE TYPES

scitype(t::Tuple) = Tuple{scitype.(t)...}


## SCITYPES OF ARRAYS ARE ARRAY TYPES

MLJBase.scitype(A::B) where {T,N,B<:AbstractArray{T,N}} =
    AbstractArray{scitype_union(A),N}


## TABLE SCITYPE

"""
    MLJBase.Table{K}

The scientific type for tabular data (a containter `X` for which
`Tables.is_table(X)=true`).

If `X` has columns `c1, c2, ..., cn`, then, by definition, 

    scitype(X) = Table{Union{scitype(c1), scitype(c2), ..., scitype(cn)}}

A special constructor of `Table` types exists: 

    `Table(T1, T2, T3, ..., Tn) <: Table` 

has the property that

    scitype(X) <: Table(T1, T2, T3, ..., Tn)

if and only if `X` is a table *and*, for every column `col` of `X`,
`scitype(col) <: Tj`, for some `j` between `1` and `n`. Note that this
constructor constructs a *type* not an instance; `Table` instances
play no role in MLJ.

    julia> X = (x1 = [10.0, 20.0, missing],
                x2 = [1.0, 2.0, 3.0],
                x3 = [4, 5, 6])

    julia> scitype(X) <: MLJBase.Table(Continuous, Count)
    false

    julia> scitype(X) <: MLJBase.Table(Union{Continuous, Missing}, Count)
    true

"""
struct Table{K} end
# struct Column{T} end

function Table(Ts...)
    Union{Ts...} <: Union{Missing, Found} ||
        error("Argements of Table scitype constructor must be subtypes of "*
              "`Union{Missing,Found}`")
    return Table{<:Union{[AbstractVector{<:T} for T in Ts]...}}
end

function scitype(X, ::Val{:table})
    #    Table{Union{[Column{T} for T in values(scitypes(X))]...}}
    Xcol = Tables.columns(X)
    col_names = propertynames(Xcol)
    types = map(col_names) do name
        scitype(getproperty(Xcol, name))
    end
    return Table{Union{types...}}
end


## SCHEMA OF SCITYPES FOR TABLES

"""
    scitypes(X)

Inspect the internal scitypes of a container object - the column
scitypes of a table, for example.

"""
scitypes(X) = scitypes(X, Val(container_type(X)))
scitypes(X, ::Val{:other}) = throw(ArgumentError("Unknown container type. "))

function scitypes(X, ::Val{:table})
    names =    schema(X).names
    return NamedTuple{names}(scitype_union(selectcols(X, c)) for c in names)
end





    






